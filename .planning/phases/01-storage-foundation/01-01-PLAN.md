---
phase: 01-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/kotlin/com/cocahonka/comfywhitelist/storage/WhitelistEntry.kt
  - src/main/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorage.kt
  - src/test/kotlin/com/cocahonka/comfywhitelist/storage/StorageTestBase.kt
  - src/test/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorageTest.kt
autonomous: true

must_haves:
  truths:
    - "Whitelist entries store player name and optional expiry timestamp"
    - "Entries with null expiry are permanent (never expire)"
    - "Entries with non-null expiry are valid until that timestamp"
    - "YAML storage saves entries with expiry metadata"
    - "YAML storage loads entries preserving expiry metadata"
    - "Player names are case-insensitive for lookups"
  artifacts:
    - path: "src/main/kotlin/com/cocahonka/comfywhitelist/storage/WhitelistEntry.kt"
      provides: "Data class for whitelist entries with expiry"
      exports: ["WhitelistEntry"]
      min_lines: 20
    - path: "src/main/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorage.kt"
      provides: "YAML storage with expiry support"
      contains: "WhitelistEntry"
  key_links:
    - from: "YamlStorage.kt"
      to: "WhitelistEntry.kt"
      via: "Map<String, WhitelistEntry>"
      pattern: "whitelistedPlayers.*WhitelistEntry"
    - from: "YamlStorage.isPlayerWhitelisted"
      to: "WhitelistEntry.isValid"
      via: "validity check on lookup"
      pattern: "entry\\?\\.isValid\\(\\)"
---

<objective>
Create expiry-aware whitelist storage system

Purpose: Transform simple string-based player list into timestamped entry system that supports temporary whitelist entries with automatic expiration.

Output:
- WhitelistEntry data class with player name + nullable expiry timestamp
- Modified YamlStorage using Map<String, WhitelistEntry> instead of Set<String>
- YAML format storing entries as sections with expiry property
- Updated tests validating expiry functionality
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md

# Existing storage implementation
@src/main/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorage.kt
@src/test/kotlin/com/cocahonka/comfywhitelist/storage/StorageTestBase.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WhitelistEntry data class</name>
  <files>src/main/kotlin/com/cocahonka/comfywhitelist/storage/WhitelistEntry.kt</files>
  <action>
Create new file `WhitelistEntry.kt` in the storage package with:

```kotlin
package com.cocahonka.comfywhitelist.storage

/**
 * Represents a whitelist entry with optional expiry.
 *
 * @property playerName The player's Minecraft username (case-preserved)
 * @property expiryTimestamp Epoch milliseconds when entry expires, null for permanent
 */
data class WhitelistEntry(
    val playerName: String,
    val expiryTimestamp: Long?
) {
    /**
     * Returns true if entry is valid (permanent or not yet expired).
     */
    fun isValid(): Boolean = expiryTimestamp == null || System.currentTimeMillis() < expiryTimestamp

    /**
     * Returns true if this is a permanent (non-expiring) entry.
     */
    fun isPermanent(): Boolean = expiryTimestamp == null

    /**
     * Returns remaining time in milliseconds, or null if permanent.
     * Returns negative value if already expired.
     */
    fun remainingTimeMillis(): Long? = expiryTimestamp?.let { it - System.currentTimeMillis() }
}
```

Key design decisions:
- Nullable Long for expiry (null = permanent, simpler than sealed class)
- Player name stored as-provided (case preserved for display)
- `isValid()` checks current time against expiry
- `remainingTimeMillis()` for display purposes in later phases
  </action>
  <verify>File exists and compiles: `./gradlew compileKotlin`</verify>
  <done>WhitelistEntry.kt exists with data class containing playerName, expiryTimestamp, isValid(), isPermanent(), remainingTimeMillis()</done>
</task>

<task type="auto">
  <name>Task 2: Modify YamlStorage for expiry support</name>
  <files>src/main/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorage.kt</files>
  <action>
Update YamlStorage to use WhitelistEntry instead of String:

1. Change `whitelistedPlayers` from `MutableSet<String>` to `MutableMap<String, WhitelistEntry>` where key is lowercase player name

2. Update companion object constants:
```kotlin
companion object {
    private const val PLAYERS_KEY = "players"
    private const val EXPIRY_KEY = "expiry"
    private const val FILE_NAME = "whitelist.yml"
}
```

3. Update `addPlayer(username: String)` to add permanent entry:
```kotlin
override fun addPlayer(username: String): Boolean {
    val normalized = username.lowercase()
    if (whitelistedPlayers.containsKey(normalized)) {
        return false // Already exists
    }
    whitelistedPlayers[normalized] = WhitelistEntry(username, null)
    return save()
}
```

4. Add new method for expiry-based adds (internal, not part of Storage interface):
```kotlin
fun addPlayerWithExpiry(username: String, expiryTimestamp: Long?): Boolean {
    val normalized = username.lowercase()
    whitelistedPlayers[normalized] = WhitelistEntry(username, expiryTimestamp)
    return save()
}
```

5. Add method to get entry (for commands to check remaining time):
```kotlin
fun getEntry(username: String): WhitelistEntry? {
    return whitelistedPlayers[username.lowercase()]
}
```

6. Update `removePlayer`:
```kotlin
override fun removePlayer(username: String): Boolean {
    return (whitelistedPlayers.remove(username.lowercase()) != null).also { if (it) save() }
}
```

7. Update `clear`:
```kotlin
override fun clear(): Boolean {
    whitelistedPlayers.clear()
    return save()
}
```

8. Update `isPlayerWhitelisted` to check validity:
```kotlin
override fun isPlayerWhitelisted(username: String): Boolean {
    val entry = whitelistedPlayers[username.lowercase()]
    return entry?.isValid() == true
}
```

9. Update `getAllWhitelistedPlayers` to return only valid entries:
```kotlin
override fun getAllWhitelistedPlayers(): Set<String> {
    return whitelistedPlayers.values
        .filter { it.isValid() }
        .map { it.playerName }
        .toSet()
}
```

10. Update `load()` to read new YAML format with backward compatibility:
```kotlin
override fun load(): Boolean {
    return try {
        if (!storageFile.exists()) {
            storageFile.parentFile.mkdirs()
            storageFile.createNewFile()
        }
        config.load(storageFile)
        whitelistedPlayers.clear()

        // Try new format first (section-based)
        val section = config.getConfigurationSection(PLAYERS_KEY)
        if (section != null) {
            section.getKeys(false).forEach { playerName ->
                val expiry = section.get("$playerName.$EXPIRY_KEY") as? Long
                whitelistedPlayers[playerName.lowercase()] = WhitelistEntry(playerName, expiry)
            }
        } else {
            // Fallback: old format (list of strings) - migrate to permanent entries
            config.getStringList(PLAYERS_KEY).forEach { playerName ->
                whitelistedPlayers[playerName.lowercase()] = WhitelistEntry(playerName, null)
            }
        }
        true
    } catch (e: Exception) {
        getLogger().warning(e.stackTraceToString())
        false
    }
}
```

11. Update `save()` to write new YAML format:
```kotlin
override fun save(): Boolean {
    return try {
        config.set(PLAYERS_KEY, null) // Clear section first
        whitelistedPlayers.values.forEach { entry ->
            config.set("$PLAYERS_KEY.${entry.playerName}.$EXPIRY_KEY", entry.expiryTimestamp)
        }
        config.save(storageFile)
        true
    } catch (e: Exception) {
        getLogger().warning(e.stackTraceToString())
        false
    }
}
```

Important:
- Keep implementing `Storage` interface from comfy-whitelist-api (don't change interface)
- Normalize to lowercase for map keys to ensure case-insensitive lookups
- Preserve original case in WhitelistEntry.playerName for display
- Support both old list format (migration) and new section format (going forward)
  </action>
  <verify>Compile succeeds: `./gradlew compileKotlin`</verify>
  <done>YamlStorage uses Map<String, WhitelistEntry>, supports expiry-based adds, checks validity on lookup, reads/writes section-based YAML format</done>
</task>

<task type="auto">
  <name>Task 3: Update storage tests for expiry functionality</name>
  <files>
    src/test/kotlin/com/cocahonka/comfywhitelist/storage/StorageTestBase.kt
    src/test/kotlin/com/cocahonka/comfywhitelist/storage/YamlStorageTest.kt
  </files>
  <action>
Update StorageTestBase.kt to add expiry-specific tests. Note: StorageTestBase tests the Storage interface, so keep existing tests but add YamlStorage-specific tests in YamlStorageTest.kt.

In YamlStorageTest.kt, add these tests (the file should extend StorageTestBase):

```kotlin
@Test
fun `add player with expiry`() {
    val storage = createStorage() as YamlStorage
    val playerName = "tempPlayer"
    val expiryTime = System.currentTimeMillis() + 86400000L // +1 day

    storage.addPlayerWithExpiry(playerName, expiryTime)
    assertTrue(storage.isPlayerWhitelisted(playerName))

    val entry = storage.getEntry(playerName)
    assertNotNull(entry)
    assertEquals(expiryTime, entry!!.expiryTimestamp)
    assertFalse(entry.isPermanent())
}

@Test
fun `expired player is not whitelisted`() {
    val storage = createStorage() as YamlStorage
    val playerName = "expiredPlayer"
    val pastTime = System.currentTimeMillis() - 1000L // 1 second ago

    storage.addPlayerWithExpiry(playerName, pastTime)
    assertFalse(storage.isPlayerWhitelisted(playerName))
}

@Test
fun `permanent player is always valid`() {
    val storage = createStorage() as YamlStorage
    val playerName = "permanentPlayer"

    storage.addPlayerWithExpiry(playerName, null)
    assertTrue(storage.isPlayerWhitelisted(playerName))

    val entry = storage.getEntry(playerName)
    assertNotNull(entry)
    assertTrue(entry!!.isPermanent())
    assertTrue(entry.isValid())
}

@Test
fun `getAllWhitelistedPlayers excludes expired entries`() {
    val storage = createStorage() as YamlStorage
    val validPlayer = "validPlayer"
    val expiredPlayer = "expiredPlayer"

    storage.addPlayerWithExpiry(validPlayer, System.currentTimeMillis() + 86400000L)
    storage.addPlayerWithExpiry(expiredPlayer, System.currentTimeMillis() - 1000L)

    val players = storage.allWhitelistedPlayers
    assertTrue(players.contains(validPlayer))
    assertFalse(players.contains(expiredPlayer))
}

@Test
fun `case insensitive player lookup`() {
    val storage = createStorage() as YamlStorage
    storage.addPlayer("TestPlayer")

    assertTrue(storage.isPlayerWhitelisted("testplayer"))
    assertTrue(storage.isPlayerWhitelisted("TESTPLAYER"))
    assertTrue(storage.isPlayerWhitelisted("TestPlayer"))
}

@Test
fun `save and load preserves expiry timestamps`() {
    val storage = createStorage() as YamlStorage
    val playerName = "timedPlayer"
    val expiryTime = System.currentTimeMillis() + 86400000L

    storage.addPlayerWithExpiry(playerName, expiryTime)
    assertTrue(storage.save())

    val storage2 = createStorage() as YamlStorage
    assertTrue(storage2.load())

    val entry = storage2.getEntry(playerName)
    assertNotNull(entry)
    assertEquals(expiryTime, entry!!.expiryTimestamp)
}

@Test
fun `getEntry returns null for non-existent player`() {
    val storage = createStorage() as YamlStorage
    assertNull(storage.getEntry("nonExistent"))
}
```

Ensure imports include:
- `org.junit.jupiter.api.Assertions.*`
- `org.junit.jupiter.api.Test`

Keep existing tests in StorageTestBase.kt unchanged - they test the Storage interface contract which should still work.
  </action>
  <verify>All tests pass: `./gradlew test`</verify>
  <done>New tests exist for expiry functionality: add with expiry, expired check, permanent check, getAllWhitelistedPlayers filtering, case-insensitive lookup, save/load preserves expiry</done>
</task>

</tasks>

<verification>
1. `./gradlew compileKotlin` - All code compiles
2. `./gradlew test` - All tests pass (existing + new expiry tests)
3. Manual verification of YAML format:
   - Create storage, add player with expiry
   - Check whitelist.yml shows section-based format with expiry property
</verification>

<success_criteria>
- WhitelistEntry data class exists with isValid(), isPermanent(), remainingTimeMillis()
- YamlStorage stores entries as Map<String, WhitelistEntry>
- YamlStorage.isPlayerWhitelisted() returns false for expired entries
- YamlStorage.getAllWhitelistedPlayers() excludes expired entries
- YAML file format is section-based: `players: { PlayerName: { expiry: <timestamp|null> } }`
- Case-insensitive lookups work (Notch == notch == NOTCH)
- All existing Storage interface tests pass
- New expiry-specific tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-01-SUMMARY.md`
</output>
